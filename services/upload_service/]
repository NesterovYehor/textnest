package coordinators

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	jsonlog "github.com/NesterovYehor/TextNest/pkg/logger"
	pb "github.com/NesterovYehor/TextNest/services/upload_service/api"
	"github.com/NesterovYehor/TextNest/services/upload_service/internal/config"
	"github.com/NesterovYehor/TextNest/services/upload_service/internal/models"
	"github.com/NesterovYehor/TextNest/services/upload_service/internal/repository"
	"github.com/NesterovYehor/TextNest/services/upload_service/internal/services"
)

type UploadCoordinator struct {
	metadataService *services.MetadataManagementService
	storageService  *services.ContentManagementService
	cfg             *config.Config
	log             *jsonlog.Logger
	pb.UnimplementedPasteUploadServer
}

func NewUploadCoordinator(cfg *config.Config, log *jsonlog.Logger, db *sql.DB) (*UploadCoordinator, error) {
	metadataRepo := repository.NewMetadataRepository(db)
	storageRepo, err := repository.NewContentRepository(cfg.BucketName)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize S3 repository: %w", err)
	}
	return &UploadCoordinator{
		metadataService: services.NewMetadataManagementService(metadataRepo, log),
		storageService:  services.NewStorageService(storageRepo, log),
		cfg:             cfg,
		log:             log,
	}, nil
}

func (uc *UploadCoordinator) UploadPaste(ctx context.Context, req *pb.UploadPasteRequest) (*pb.UploadPasteResponse, error) {
	metadata := models.MetaData{
		Key:            req.Key,
		ExpirationDate: req.ExpirationDate.AsTime(),
		CreatedAt:      time.Now(),
		UserId:         req.UserId,
	}
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	var wg sync.WaitGroup
	errorCh := make(chan error, 2)

	wg.Add(2)
	go func() {
		defer wg.Done()
		errorCh <- uc.metadataService.ValidateAndSave(ctx, &metadata)
	}()

	go func() {
		defer wg.Done()
		errorCh <- uc.storageService.SaveContent(ctx, metadata.Key, req.Data)
	}()

	wg.Wait()
	close(errorCh)

	combinedErr := collectErrors(errorCh)
	return uc.prepareResponse(metadata.Key, combinedErr)
}

func (uc *UploadCoordinator) UploadUpdates(ctx context.Context, req *pb.UploadUpdatesRequest) (*pb.UploadUpdatesResponse, error) {
	userId, err := uc.metadataService.IsPasteExist(ctx, req.Key)
	if err != nil {
		return nil, err
	}
	if userId != req.UserId {
		return nil, errors.New("Only author is able to edit paste")
	}

	var wg sync.WaitGroup
	errorCh := make(chan error, 2)

	if req.ExpirationDate != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			errorCh <- uc.metadataService.UpdateMetadata(ctx, req.Key, req.ExpirationDate.AsTime())
		}()
	}
	if req.Content != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			errorCh <- uc.storageService.UpdateContent(ctx, req.Key, req.Content)
		}()
	}

	wg.Wait()
	close(errorCh)

	combineErr := collectErrors(errorCh)
	if combineErr != nil {
		return nil, combineErr
	}
	return &pb.UploadUpdatesResponse{Message: "Paste updated successfully"}, nil
}

func (uc *UploadCoordinator) ExpirePaste(ctx context.Context, req *pb.ExpirePasteRequest) (*pb.ExpirePasteResponse, error) {
	userId, err := uc.metadataService.IsPasteExist(ctx, req.Key)
	if err != nil {
		return nil, err
	}
	if userId == req.UserId {
		return nil, errors.New("Only author is able to expire paste")
	}
	if err := uc.metadataService.UpdateMetadata(ctx, req.Key, time.Now()); err != nil {
		return nil, err
	}
	return &pb.ExpirePasteResponse{
		Message: "Paste expired successfully",
	}, nil
}

func collectErrors(errorCh <-chan error) error {
	var errorMessages []string
	for err := range errorCh {
		if err != nil {
			errorMessages = append(errorMessages, err.Error())
		}
	}

	if len(errorMessages) > 0 {
		return fmt.Errorf(strings.Join(errorMessages, "; "))
	}
	return nil
}

func (uc *UploadCoordinator) prepareResponse(key string, err error) (*pb.UploadPasteResponse, error) {
	if err != nil {
		uc.log.PrintError(context.Background(), err, map[string]string{"key": key})
		return &pb.UploadPasteResponse{Message: "Failed to upload: " + err.Error()}, nil
	}

	uc.log.PrintInfo(context.Background(), "Upload successful", map[string]string{"key": key})
	return &pb.UploadPasteResponse{Message: "Upload successful"}, nil
}
